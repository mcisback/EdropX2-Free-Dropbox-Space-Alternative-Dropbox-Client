'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _dropbox = require('dropbox');

var _dropbox2 = _interopRequireDefault(_dropbox);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var TYPE_KEY = '@@fsType';

/**
 * Convert an object to fs-like stat object
 * 
 * @param {Object} entry
 * @returns {Object}
 */
function __convertToStat(entry) {
    return Object.assign({}, entry, {
        isFile: function isFile() {
            return entry['.tag'] === 'file';
        },
        isDirectory: function isDirectory() {
            return entry['.tag'] === 'folder';
        }
    });
}

/**
 * Execute a callback async
 * Borrowed from: https://github.com/perry-mitchell/webdav-fs/blob/master/source/index.js#L19
 * 
 * @param {Function} callback
 * @param {Array.<Any>} args
 */
function __executeCallbackAsync(callback, args) {
    if (typeof setImmediate !== "undefined") {
        setImmediate(function () {
            callback.apply(null, args);
        });
    } else {
        setTimeout(function () {
            callback.apply(null, args);
        }, 0);
    }
}

/**
 * Normalize an input path string or buffer
 * Dropbox doesnâ€™t allow '/' for root, it should be an empty string
 * and some users prefer to prefix the path with a dot.
 * 
 * @param {String|Buffer} remotePath
 * @returns {String}
 */
function __normalizePath(remotePath) {
    if (remotePath instanceof Buffer) {
        remotePath = remotePath.toString('utf8');
    }

    if (remotePath === '/') {
        return '';
    }

    if (remotePath.indexOf('./') === 0) {
        return remotePath.replace(/\.\//, '');
    }

    return remotePath;
}

/**
 * Create an fs-like API for Dropbox
 * 
 * @param {{
 *  apiKey: String,
 *  client: Dropbox
 * }} Configuration object
 * @returns {Object}
 */

exports.default = function () {
    var _api;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var _ref$apiKey = _ref.apiKey;
    var apiKey = _ref$apiKey === undefined ? null : _ref$apiKey;
    var _ref$client = _ref.client;
    var client = _ref$client === undefined ? null : _ref$client;


    if (!client && typeof apiKey === 'string') {
        client = new _dropbox2.default({
            accessToken: apiKey
        });
    } else if (!client) {
        throw new Error('Dropbox client or apiKey should be provided.');
    }

    var api = (_api = {}, _defineProperty(_api, TYPE_KEY, "dropbox-fs"), _defineProperty(_api, 'readdir', function readdir() {
        var remotePath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var callback = arguments[2];

        if (typeof options === 'function') {
            callback = options;
            options = {};
        }

        var mode = options.mode || 'node';

        client.filesListFolder({ path: __normalizePath(remotePath) }).then(function (_ref2) {
            var entries = _ref2.entries;

            if (mode === 'node') {
                entries = entries.map(function (entry) {
                    return entry.name;
                });
            } else if (mode === 'stat') {
                entries = entries.map(function (entry) {
                    return __convertToStat(entry);
                });
            } else {
                throw new Error('Unknow mode: ' + mode);
            }
            __executeCallbackAsync(callback, [null, entries]);
        }).catch(callback);
    }), _defineProperty(_api, 'mkdir', function mkdir(remotePath, callback) {
        client.filesCreateFolder({ path: __normalizePath(remotePath) }).then(function (meta) {
            meta['.tag'] = 'folder';
            meta = __convertToStat(meta);
            __executeCallbackAsync(callback, [null, meta]);
        }).catch(callback);
    }), _defineProperty(_api, 'readFile', function readFile(remotePath) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { encoding: null };
        var callback = arguments[2];

        if (typeof options === 'function') {
            callback = options;
            options = {
                encoding: null
            };
        } else if (typeof options === 'string') {
            options = {
                encoding: options
            };
        }

        var _options = options;
        var encoding = _options.encoding;


        client.filesDownload({ path: __normalizePath(remotePath) }).then(function (resp) {
            if (resp.fileBinary) {
                // Probably running in node: `fileBinary` is passed
                var buffer = Buffer.from(resp.fileBinary);
                buffer = encoding ? buffer.toString(encoding) : buffer;
                __executeCallbackAsync(callback, [null, buffer]);
            } else {
                (function () {
                    // Probably browser environment: use FileReader + ArrayBuffer
                    var fileReader = new FileReader();
                    var buffer = void 0;
                    fileReader.onload = function () {
                        buffer = Buffer.from(this.result);
                        buffer = encoding ? buffer.toString(encoding) : buffer;
                        __executeCallbackAsync(callback, [null, buffer]);
                    };
                    fileReader.readAsArrayBuffer(resp.fileBlob);
                })();
            }
        }).catch(callback);
    }), _defineProperty(_api, 'rename', function rename(fromPath, toPath, callback) {
        client.filesMove({
            from_path: __normalizePath(fromPath),
            to_path: __normalizePath(toPath)
        }).then(function () {
            __executeCallbackAsync(callback, [null]);
        }).catch(callback);
    }), _defineProperty(_api, 'stat', function stat(remotePath, callback) {
        client.filesGetMetadata({ path: __normalizePath(remotePath) }).then(function (meta) {
            meta = __convertToStat(meta);
            __executeCallbackAsync(callback, [null, meta]);
        }).catch(callback);
    }), _defineProperty(_api, 'unlink', function unlink(remotePath, callback) {
        client.filesDelete({ path: __normalizePath(remotePath) }).then(function () {
            __executeCallbackAsync(callback, [null]);
        }).catch(callback);
    }), _defineProperty(_api, 'writeFile', function writeFile(remotePath, data) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var callback = arguments[3];

        if (typeof options === 'function') {
            callback = options;
            options = {};
        } else if (typeof options === 'string') {
            options = {
                encoding: options
            };
        }

        options = Object.assign({
            overwrite: true,
            encoding: 'utf8'
        }, options);

        var uploadOpts = {
            path: __normalizePath(remotePath),
            contents: data instanceof Buffer ? data : Buffer.from(data, options.encoding)
        };

        if (options.overwrite !== false) {
            uploadOpts.mode = {
                '.tag': 'overwrite'
            };
        }

        client.filesUpload(uploadOpts).then(function (meta) {
            meta['.tag'] = 'file';
            meta = __convertToStat(meta);
            __executeCallbackAsync(callback, [null, meta]);
        }).catch(callback);
    }), _api);

    api.rmdir = api.unlink;

    return api;
};

module.exports = exports['default'];